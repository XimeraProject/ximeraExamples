<!DOCTYPE html> 
<html lang='en-US' xml:lang='en-US'> 
<head> <title>Linear Equations: Equations of Lines</title> 
<meta charset='utf-8' /> 
<meta content='TeX4ht (https://tug.org/tex4ht/)' name='generator' /> 
<meta content='width=device-width,initial-scale=1' name='viewport' /> 
<link href='\aa:CssFile ' rel='stylesheet' type='text/css' /> 
<meta content='2-1-3LinearEquations_Forms.online.tex' name='src' /> 
<script>window.MathJax = { tex: { tags: "ams", }, }; </script> 
<script async='async' id='MathJax-script' src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js' type='text/javascript'></script>  
<meta content='Elizabeth Miller' name='author' /> 
<meta content='version 2.5.1' name='ximera' /> 
<link href='https://ximera.osu.edu/public/stylesheets/standalone.css' media='screen' rel='stylesheet' /> 
<script async='' src='https://ximera.osu.edu/public/javascripts/standalone.min.js' type='text/javascript'></script> 
</head><body> 
<div class='preamble'>
</div>
<style> .activity-body pre { white-space: pre; background-color: lightgray; } .xmyoutube { aspect-ratio: 16/9; min-width: 75%; } .image-environment img { width: unset; } </style> 
  
<div class='abstract'>
<!-- l. 12 --><p class='noindent'>We explore the different ways we might write the equation of a line including the
slope-intercept form, the point-slope form, and standard form.</p> 
</div>
<div class='maketitle'></div><p>We will explore how to write an equation for a line. The best way to write the
equation of a line depends both on what information we have about the line and
what we want to do with our equation.
</p><h3 class='sectionHead' id='slopeintercept-form-of-a-line'><span class='titlemark'>1   </span> <a id='x1-10001'></a>Slope-Intercept Form of a Line</h3>
<!-- l. 23 --><p class='noindent'>Recall the previous example where Yara had $50 in her savings account when the
year began, and decided to deposit $20 each week without withdrawing any money.
In that example, we model using <span class='mathjax-inline'>\(x\)</span> to represent how many weeks have passed.
After <span class='mathjax-inline'>\(x\)</span> weeks, Yara has added <span class='mathjax-inline'>\(20x\)</span> dollars. And since she started with $50, she
has
</p><!-- l. 25 --><p class='noindent'>
</p><div class='mathjax-block'>                                 
\[y=20x+50\]
</div>
<!-- l. 27 --><p class='noindent'>in her account after <span class='mathjax-inline'>\(x\)</span> weeks. In this example, there is a constant rate of change of 20
dollars per week, so we call that the slope. We also saw that plotting Yara’s balance
over time gives us a straight-line graph.
</p>
                                                                  

                                                                  
<div aria-labelledby='image-alt-1' class='image-environment' role='img'> <img alt='[Picture]' src='2-1-3LinearEquations_Forms.online-ad7a62b146c69aaa200a692f9e12b94f.svg' /> </div>
<!-- l. 61 --><p class='noindent'>The graph of Yara’s savings has some things in common with almost every
straight-line graph. There is a slope, and there is a place where the line crosses the y
-axis. We use the symbol, <span class='mathjax-inline'>\(m\)</span>, for the slope of a line.
</p>
<div aria-labelledby='image-alt-2' class='image-environment' role='img'> <img alt='[Picture]' src='2-1-3LinearEquations_Forms.online-a3bbc6cda076daf3d5aba067b970ee8b.svg' /> </div>
<div class='theorem-like problem-environment definition' id='problem1'><a id='x1-1001r1'></a>The <span class='mathjax-inline'>\(y\)</span>-intercept is a point on the <span class='mathjax-inline'>\(y\)</span>-axis where the line crosses. Since it’s on the <span class='mathjax-inline'>\(y\)</span>-axis,
the <span class='mathjax-inline'>\(x\)</span>-coordinate of this point is 0. It is standard to call the point <span class='mathjax-inline'>\((0,b)\)</span> the <span class='mathjax-inline'>\(y\)</span>-intercept, and
call the number <span class='mathjax-inline'>\(b\)</span> the <span class='mathjax-inline'>\(y\)</span>-coordinate of the <span class='mathjax-inline'>\(y\)</span>-intercept. </div>
<!-- l. 79 --><p class='noindent'>One way to write the equation for Yara’s savings was
                                                                  

                                                                  
</p><div class='mathjax-block'>                                 
\[y=20x+50\]
</div><p> where both <span class='mathjax-inline'>\(m=20\)</span> and <span class='mathjax-inline'>\(b=50\)</span> are immediately visible in the equation. Now we are ready to
generalize this.
</p><div class='theorem-like problem-environment definition' id='problem2'><a id='x1-1002r2'></a>When <span class='mathjax-inline'>\(x\)</span> and <span class='mathjax-inline'>\(y\)</span> have a linear relationship where <span class='mathjax-inline'>\(m\)</span> is the slope and <span class='mathjax-inline'>\((0,b)\)</span> is the <span class='mathjax-inline'>\(y\)</span>-intercept, one
equation for this relationship is
<div class='mathjax-block'>                                 
\[y=mx+b\]
</div> and this equation is called the <strong>slope-intercept form</strong> of the line. It is called this
because the slope and <span class='mathjax-inline'>\(y\)</span>-intercept are immediately discernible from the numbers in the
equation. </div>
<div class='problem-environment problem' id='problem3' role='article'><a id='x1-1003r3'></a> What is the slope and <span class='mathjax-inline'>\(y\)</span>-intercept for the line with the following linear equation?
<div class='mathjax-block'>                                 
\[y=17x-14\]
</div>
                                                                  

                                                                  
<!-- l. 91 --><p class='noindent'>Slope = <span class='mathjax-inline'>\(\answer [given]{17}\) \(y\)</span>-intercept=<span class='mathjax-inline'>\((0,\answer [given]{-14})\)</span> </p><div class='accordion'> 
<h3 class='xmhint'></h3> 
<div class='accordion-item xmhint-content' id='accordion-item4'> 
 Note that since the formula for slope-intercept form of a line
has a ""between the <span class='mathjax-inline'>\(mx\)</span> and the <span class='mathjax-inline'>\(b\)</span>, this means that an equation like <span class='mathjax-inline'>\(y=17x-14\)</span> needs to
looked at like <span class='mathjax-inline'>\(y=17x+(-14)\)</span> so that it matches the formula for the slope-intercept form of a
line.</div> 
</div> 

</div>
<div class='theorem-like problem-environment remark' id='problem5'><a id='x1-1004r4'></a>The number <span class='mathjax-inline'>\(b\)</span> is the <span class='mathjax-inline'>\(y\)</span>-value when <span class='mathjax-inline'>\(x=0\)</span>. Therefore it is common to refer to <span class='mathjax-inline'>\(b\)</span> as the <strong>initial
value</strong> or <strong>starting value</strong> of a linear relationship. </div>
<!-- l. 110 --><p class='noindent'>
</p>
<h3 class='sectionHead' id='pointslope-form-of-a-line'><span class='titlemark'>2   </span> <a id='x1-20002'></a>Point-Slope Form of a Line</h3>
<!-- l. 112 --><p class='noindent'>In the previous section, we learned that a linear equation can be written in
slope-intercept form, <span class='mathjax-inline'>\(y=mx+b\)</span>. This section covers an alternative that is often more useful,
especially in Calculus: point-slope form.
</p>
<div class='theorem-like problem-environment example' id='problem6'><a id='x1-2001r5'></a>Starting in 1990, the population of the United States has been growing by about
2.865 million people per year. Also, back in 1990, the population was 253 million.
Since the rate of growth has been roughly constant, a linear model is appropriate.
Let’s try to write an equation to model this.
<div class='theorem-like problem-environment explanation' id='problem7'><a id='x1-2002r6'></a>We consider using <span class='mathjax-inline'>\(y=mx+b\)</span>, but we would need to know the <span class='mathjax-inline'>\(y\)</span>-intercept, and nothing in the
background tells us that. We’d need to know the population of the United States in
the year 0, before there even was a United States.
<!-- l. 120 --><p class='noindent'>We could do some side work to calculate the <span class='mathjax-inline'>\(y\)</span>-intercept, but let’s try something else.
Here are some things we know:
</p>     
<dl class='enumerate-enumitem'><dt class='enumerate-enumitem'>
(a) 
</dt><dd class='enumerate-enumitem'>The slope equation is <span class='mathjax-inline'>\(m=\frac {y_2-y_1}{x_2-x_1}\)</span>
</dd>     
<dt class='enumerate-enumitem'>
(b) 
</dt><dd class='enumerate-enumitem'>The slope is <span class='mathjax-inline'>\(m=2.865 \frac {\text {million people}}{\text {year}}\)</span>
</dd>     
<dt class='enumerate-enumitem'>
(c) 
</dt><dd class='enumerate-enumitem'>One point on the line is <span class='mathjax-inline'>\((1990,253)\)</span> because in 1990, the population was 253 million.</dd></dl>
<!-- l. 127 --><p class='noindent'>If we use the generic <span class='mathjax-inline'>\((x,y)\)</span> to represent a point <em>somewhere</em> on this line, then the rate of
change between <span class='mathjax-inline'>\((1990,253)\)</span> and <span class='mathjax-inline'>\((x,y)\)</span> has to be 2.965. So
</p><!-- l. 129 --><p class='noindent'>
                                                                  

                                                                  
</p><div class='mathjax-block'>                                 
\[\frac {y-253}{x-1990}=2.865\]
</div>.
<!-- l. 131 --><p class='noindent'>While this is an equation of a line, we might prefer to write the equation without
using a fraction. Multiplying both sides by <span class='mathjax-inline'>\((x-1990)\)</span> gives us
</p><!-- l. 133 --><p class='noindent'>
</p><div class='mathjax-block'>                                 
\[y-253=2.865(x-1990)\]
</div>
<!-- l. 135 --><p class='noindent'>This is a good place to stop. We have isolated <span class='mathjax-inline'>\(y\)</span>, and three meaningful numbers appear
in the equation: the rate of growth, a certain year, and the population in that year.
This is a specific example of point-slope form. </p></div> </div>
<div class='theorem-like problem-environment definition' id='problem8'><a id='x1-2006r7'></a>When <span class='mathjax-inline'>\(x\)</span> and <span class='mathjax-inline'>\(y\)</span> have a linear relationship where <span class='mathjax-inline'>\(m\)</span> is the slope and <span class='mathjax-inline'>\((x_0,y_0)\)</span> is some specific point
that the line passes through, one equation for this relationship is
<div class='mathjax-block'>                                 
\[y-y_0=m(x-x_0)\]
</div> and this equation is called the point-slope form of the line. It is called this because
                                                                  

                                                                  
the slope and one point on the line are immediately discernible from the numbers in
the equation.
<div aria-labelledby='image-alt-3' class='image-environment' role='img'> <img alt='[Picture]' src='2-1-3LinearEquations_Forms.online-ce78a6869a839f1ed50757ddd67a3011.svg' /> </div>
</div>
<!-- l. 159 --><p class='noindent'>Sometimes, it is helpful to be able to express our equation as <span class='mathjax-inline'>\(y=...\)</span>. To do this
when working with the Point-Slope form of a line, all you have to do is add <span class='mathjax-inline'>\(y_0\)</span>
to both sides of the equation. This will give us the Alternate Point-Slope
Form.
</p>
<div class='theorem-like problem-environment definition' id='problem9'><a id='x1-2007r8'></a>When <span class='mathjax-inline'>\(x\)</span> and <span class='mathjax-inline'>\(y\)</span> have a linear relationship where <span class='mathjax-inline'>\(m\)</span> is the slope and <span class='mathjax-inline'>\((x_0,y_0)\)</span> is some specific point
that the line passes through, one equation for this relationship is
<div class='mathjax-block'>                                 
\[y=m(x-x_0)+y_0\]
</div> and this equation is called the (alternate) point-slope form of the line. It is called
this because the slope and one point on the line are immediately discernible from the
numbers in the equation. </div>
<!-- l. 169 --><p class='noindent'>Note that some people may call this second form the Point-Slope Form of a
line. Both ways of writing this form have the advantage that they can be
easily written down if you just know a point on the line and the slope of the
line.
                                                                  

                                                                  
</p><!-- l. 175 --><p class='noindent'>
</p>
<h3 class='sectionHead' id='standard-form-of-a-line'><span class='titlemark'>3   </span> <a id='x1-30003'></a>Standard Form of a Line</h3>
<!-- l. 177 --><p class='noindent'>We’ve seen that a linear relationship can be expressed with an equation in
Slope-Intercept form or with an equation in Point-Slope form. There is a
third form that you can use to write line equations. It’s known as standard
form.
</p><!-- l. 179 --><p class='noindent'>Imagine trying to gather donations to pay for a $10,000 medical procedure you
cannot afford. Oversimplifying the mathematics a bit, suppose that there were only
two types of donors in the world: those who will donate $20 and those who will
donate $100.
</p><!-- l. 181 --><p class='noindent'>How many of each, or what combination, do you need to reach the funding goal? As
in, if <span class='mathjax-inline'>\(x\)</span> people donate $20 and <span class='mathjax-inline'>\(y\)</span> people donate $100, what numbers could <span class='mathjax-inline'>\(x\)</span> and <span class='mathjax-inline'>\(y\)</span> be? The
donors of the first type have collectively donated <span class='mathjax-inline'>\(20x\)</span> dollars, and the donors of the
second type have collectively donated <span class='mathjax-inline'>\(100y\)</span>.
</p><!-- l. 183 --><p class='noindent'>So altogether you’d need
</p><!-- l. 185 --><p class='noindent'>
</p><div class='mathjax-block'>                                 
\[20x+100y=10000\]
</div>
<!-- l. 187 --><p class='noindent'>This is an example of a line equation in standard form.
</p>
<div class='theorem-like problem-environment definition' id='problem10'><a id='x1-3001r9'></a>It is always possible to write an equation for a line in the form
<div class='mathjax-block'>
                                                                  

                                                                  
\[Ax+By=C\]
</div> where <span class='mathjax-inline'>\(A\)</span>,<span class='mathjax-inline'>\(B\)</span>, and <span class='mathjax-inline'>\(C\)</span> are three numbers (each of which might be 0, although at least one of <span class='mathjax-inline'>\(A\)</span>
and <span class='mathjax-inline'>\(B\)</span> must be nonzero). This form of a line equation is called standard form.
</div>
<!-- l. 197 --><p class='noindent'>In the context of an application, the meaning of <span class='mathjax-inline'>\(A\)</span>, <span class='mathjax-inline'>\(B\)</span>, and <span class='mathjax-inline'>\(C\)</span> depends on that context.
This equation is called standard form perhaps because any line can be written this
way, even vertical lines (which cannot be written using slope-intercept or point-slope
form equations).
</p><!-- l. 200 --><p class='noindent'>
</p>
<h3 class='sectionHead' id='special-lines'><span class='titlemark'>4   </span> <a id='x1-40004'></a>Special Lines</h3>
<!-- l. 201 --><p class='noindent'>While we can write the equation of a line in different forms, it is important to note
that we can easily rearrange a line given in one form to another form using
algebra.
</p><!-- l. 203 --><p class='noindent'>There are two special types of lines which it is worth mentioning at this
point.
</p>
<div class='theorem-like problem-environment definition' id='problem11'><a id='x1-4001r10'></a>A horizontal line is a line where all the <span class='mathjax-inline'>\(y\)</span>-values of the points are the same. In this
case, if the <span class='mathjax-inline'>\(y\)</span>-value is <span class='mathjax-inline'>\(y_0\)</span>, then the line can be written as
<div class='mathjax-block'>                                 
\[y=y_0\]
</div>
<div class='center'>
<!-- l. 209 --><p class='noindent'>
                                                                  

                                                                  
</p><!-- l. 210 --><p class='noindent'><img alt='[Picture]' src='2-1-3LinearEquations_Forms.online-9c2426b5bcfde1565e3e7f4fa3bf8eea.svg' /></p></div>
</div>
<div class='theorem-like problem-environment definition' id='problem12'><a id='x1-4002r11'></a>A vertical line is a line where all the <span class='mathjax-inline'>\(x\)</span>-values of the points are the same. In this case, if
the <span class='mathjax-inline'>\(x\)</span>-value is <span class='mathjax-inline'>\(x_0\)</span>, then the line can be written as
<div class='mathjax-block'>                                 
\[x=x_0\]
</div>
<div class='center'>
<!-- l. 227 --><p class='noindent'>
</p><!-- l. 228 --><p class='noindent'><img alt='[Picture]' src='2-1-3LinearEquations_Forms.online-577505e3dd8cd98f5b6c37cb9f70db15.svg' /></p></div>
</div><div class='javascript' id='javascript13'><script type='text/javascript'>
var debugInfo = false;

function debugText(debugMsg) {
    if (debugInfo) {
    console.log(debugMsg);
    }
}

function debugArray(array) {
    if (debugInfo) {
    console.log(array);
    }
}


function compSubTree(f, treeOne,treeTwo) {
    /*
        We assume that the input f is the full matrix expressions object we will need for cloning,
        treeOne is a level of the tree that is used as the subtree to compare
        treeTwo is a level of another tree that is used as the subtree to compare.
        We want to see if f.treeOne = f.treeTwo in the Ximera sense of equality.
    */
    // First we duplicate the object structure so the equals command can be used without pitching a fit.
    let fTemp=Object.create(f);
    let gTemp=Object.create(f);

    // Now we assign the subtrees as the full tree of the objects.
    fTemp.tree = treeOne;
    gTemp.tree = treeTwo;

    // Now we return the validity of their equality using Ximera equality validation.
    return (fTemp.equals(gTemp))
}


// NOTE: The below are intended to be used inside an \answer optional argument with the validator key, NOT in a validator environment.

// sameDerivative checks to see if the derivative with respect to x and c are equal.
// Because of how they are loaded, I need to currently manually check each variable letter, so we do a full comparison
// Currently not checking e, f, g, h, or i as variables because they are special reserve letters in math.
  sameDerivative = function(a,b) {
    return (
    a.derivative('a').equals( b.derivative('a') ) &&
    a.derivative('b').equals( b.derivative('b') ) &&
    a.derivative('c').equals( b.derivative('c') ) &&
    a.derivative('d').equals( b.derivative('d') ) &&
    a.derivative('j').equals( b.derivative('j') ) &&
    a.derivative('k').equals( b.derivative('k') ) &&
    a.derivative('l').equals( b.derivative('l') ) &&
    a.derivative('m').equals( b.derivative('m') ) &&
    a.derivative('n').equals( b.derivative('n') ) &&
    a.derivative('o').equals( b.derivative('o') ) &&
    a.derivative('p').equals( b.derivative('p') ) &&
    a.derivative('q').equals( b.derivative('q') ) &&
    a.derivative('r').equals( b.derivative('r') ) &&
    a.derivative('s').equals( b.derivative('s') ) &&
    a.derivative('t').equals( b.derivative('t') ) &&
    a.derivative('u').equals( b.derivative('u') ) &&
    a.derivative('v').equals( b.derivative('v') ) &&
    a.derivative('w').equals( b.derivative('w') ) &&
    a.derivative('x').equals( b.derivative('x') ) &&
    a.derivative('y').equals( b.derivative('y') ) &&
    a.derivative('z').equals( b.derivative('z') ) &&
    a.derivative('A').equals( b.derivative('A') ) &&
    a.derivative('B').equals( b.derivative('B') ) &&
    a.derivative('C').equals( b.derivative('C') ) &&
    a.derivative('D').equals( b.derivative('D') ) &&
    a.derivative('J').equals( b.derivative('J') ) &&
    a.derivative('K').equals( b.derivative('K') ) &&
    a.derivative('L').equals( b.derivative('L') ) &&
    a.derivative('M').equals( b.derivative('M') ) &&
    a.derivative('N').equals( b.derivative('N') ) &&
    a.derivative('O').equals( b.derivative('O') ) &&
    a.derivative('P').equals( b.derivative('P') ) &&
    a.derivative('Q').equals( b.derivative('Q') ) &&
    a.derivative('R').equals( b.derivative('R') ) &&
    a.derivative('S').equals( b.derivative('S') ) &&
    a.derivative('T').equals( b.derivative('T') ) &&
    a.derivative('U').equals( b.derivative('U') ) &&
    a.derivative('V').equals( b.derivative('V') ) &&
    a.derivative('W').equals( b.derivative('W') ) &&
    a.derivative('X').equals( b.derivative('X') ) &&
    a.derivative('Y').equals( b.derivative('Y') ) &&
    a.derivative('Z').equals( b.derivative('Z') )
    )
  }


/*
HOW THIS SHOULD WORK:
    Initially check to make sure the submitted answer (and proposed answer) are at least in some kind of theoretically factored form.

    Next duplicate the raw trees so we can mess with them without worrying about changing the original.

    Fold up any exponents on both trees so that our root node is of the form: ['*',factor1,factor2,factor3,...].
        This includes killing off any leading negative signs (again we'll compare for equality using the original raw string)

    Now call a recursive function to deep-dive into each factor to find what degree that factor actually is.
        Will also identify if the factor isn't even a factor, in which case we will return a negative value to negate the answer.

    Once we have the degree for each factor, now we can compare the instructor degree list and student degree list as intended.
*/

// Subfunction to identify if something is a number:

function isNum(numb) {
    if ((typeof numb === 'number')||(numb=='e')||(numb=='pi'))
    {return true} else {return false}
}

// Subfunction to identify if something is a non-negative integer:

function isPosInt(numb) {
    if ((isNum(numb))&&((numb>=0)&&(numb%1==0)))
    {return true} else {return false}
}

// This does a recursion through a factor to eventually find it's degree - assuming it's a polynomial.

function degreeHunt(tree,position,curDeg) {
    //(Re)set curDeg just in case:
    var curDeg=0;

    // First, let's figure out what to do about negative signs, since they can be annoying.
    //  I think there's three possibilities, it's a negative array, a negative x, or a negative number.

    if (tree[position][0]=='-') {
        debugText('Processing a minus sign.');
        if (tree[position][1]=='x') {
            // We found a -x term within our factor, so that's degree 1 I guess!

            debugText('Found a -x term!');
            curDeg = Math.max(curDeg,1);

        } else if (Array.isArray(tree[position][1])) {
            // Else if there's a negative outside of an array, just bypass the negative and keep digging for an exponent sign.

            debugText('Found a negative Array term!');
            let tempVal = degreeHunt(tree[position],1)
            if (tempVal<0) { return (-1)} else {
                curDeg = Math.max(curDeg,tempVal);
            }

        }// Note that, if it's a negative number, I don't care about it, so no need for an else.
    } else if (tree[position][0]=='apply') {
        debugText('Processing an apply symbol.');
        // any 'apply' is inevitably a function that isn't a polynomial.
        //  Although, only if it actually has an 'x' in there - so I need to fix/update that at some point.

        // To find out if the apply is actually just a number or not, we need to recurs through every sub-node looking for an 'x'.
        //  If the degree ends up positive, then we have a variable inside the apply function it's not a polynomial.
        //  If the degree ends up zero, then it's ultimately some bizarre number formation and we're fine.

        var tempDeg = 0;

        for (var j = 1; j < tree[position].length; ++j) {
            // Walk the array to find any powers of x.
            if (tree[position][j]=='x') {
                // If the entry is just x, then we have pos deg and we are done.
                debugText('Found an x inside an apply function that suggests the factor is not actually a polynomial!');
                return (-1);
            } else if (Array.isArray(tree[position][j])) {
                // If the term is an array, then we need to recurs to find the degree.
                let tempVal=degreeHunt(tree[position],j,0);
                if (tempVal!==0) {
                    debugText('Found an issue inside an apply function that suggests the factor is not actually a polynomial!');
                    return (-1)
                }
            }// Any other option is degree 0, so no need for an else.
        }// End of for loop and end up 'apply' function
    } else if (tree[position][0]=='^') {
        // Now we process the exponent sign case, but be careful cause students do crazy shit,
        //  So it might be a x^N situation, but it might be some other shenanigans.

        debugText('Processing an exponential sign.');

        if ((tree[position][1]=='x')&&(isPosInt(tree[position][2]))) {
            // We have something like x^N

            debugText('We have x^N');

            curDeg = Math.max(curDeg,tree[position][2]);

        } else if (tree[position][1]=='x') {
            // If the base is x but it's not being raised to an integer power, then it's not a proper monomial.
            //  Note that we are assuming here that students won't put shit like 1+1 as the power, if so, it will be marked wrong.

            debugText('We have x^(g(x)) but g(x) is not a positive integer.');

            return -1;

        } else if ((isNum(tree[position][1]))&&(isNum(tree[position][2]))) {
            // This means we have a^b which is still just a number, so it's fine... but doesn't give a degree.

            debugText('We have a^b');

        } else if ((Array.isArray(tree[position][1]))&&(isPosInt(tree[position][2]))) {
            // We have something of the form (f(x))^N which might be a part of a factor.
            //  We recurse on the array, and multiply the result by the N.

            debugText('We have f(x)^N');
            let tempVal = tree[position][2]*degreeHunt(tree[position],1,curDeg);
            if (tempVal<0) { return (-1)} else {
                curDeg = Math.max(curDeg,tempVal);
            }

        } else {
            // All other situations are inevitably not polynomials.

            return (-1);
        }
    } else if (tree[position][0]=='/') {
        // This is problematic, because the only way we can allow a division is if the denominator is just a number.
        //  But if the denominator has an 'x' anywhere in it, then we have a problem...

        debugText('Processing a division sign.');

        if (tree[position][2]=='x') {
            // We're dividing by x, which is bad.

            debugText('Dividing by x, naughty naughty!');

            return (-1);
        } else if (Array.isArray(tree[position][2])) {
            //  Let's try doing a recurs, and if we get a result that isn't 0, then that means there's an 'x' so we return -1.
            if (degreeHunt(tree[position],2,0)!==0) {
                // If it's not 0, then we found an 'x' or something that invalidates the polynomial.
                return (-1)
            } // otherwise we have some kind of 'dividing by a number' situation, so it's fine, and doesn't impact degree.

        }

        // Now that we've dealt with the possibilities that cause a non-polynomial function, we can proceed assuming it is just division by a number.

        debugText('The denominator is just a number, so we need to check the numerator.');

        if (tree[position][1]=='x') {
            // If we've made it past the first two hurtles, then the bottom is just a number of some form.
            //  So if the top is 'x', then we have something like x/a which is still a degree 1 factor.
            var curDeg = Math.max(curDeg,1);
            debugText('We found a fraction with just x in the top.');
        } else if (Array.isArray(tree[position][1])) {
            // If the top of the fraction is an array - but we've already reduced to case where denominator is a number.
            //  So we need to figure out if there is a degree in the top to count.

            debugText('We found a fraction with an array for the numerator.')
            var tempVal = degreeHunt(tree[position],1,0)
            debugText('I think the numerator degree from the array is: '+tempVal);
            if (tempVal<0) { return (-1)} else {
                 var curDeg = Math.max(curDeg,tempVal);
            }

        }// Note that if none of the above, then it's just a/b, which is fine and doesn't impact degree.

    } else if (tree[position][0]=='*') {
        // If we are multiplying, we could be multiplying a bunch of terms - maybe a bunch of x terms.

        debugText('Processing a product sign.');

        var tempDeg = 0;
        for (var j = 0; j < tree[position].length; ++j) {
            // Add the degree of each thing being multiplied, even though most are probably zero.
            if (tree[position][j]=='x') {
                // If the entry is just x, then we have deg 1.
                debugText('Found a solo x term inside the product sign, degree is at least 1.')
                tempDeg = Math.max(tempDeg,1);
            } else if (Array.isArray(tree[position][j])) {
                // If the term is an array, then we need to recurs to find the degree.
                // let tempVal=degreeHunt(tree[position],j,0);
                if (degreeHunt(tree[position],j,0)<0) {
                    return (-1)
                } else if (degreeHunt(tree[position],j,0)==0){
                    debugText('No degree term found inside product sign, so we stay at degree: '+tempDeg);
                } else {
                    debugText('found a higher degree term inside the product sign, degree is at least: '+tempDeg);
                    tempDeg = Math.max(tempDeg,degreeHunt(tree[position],j,0));
                }
            }// Any other option is degree 0, so no need for an else.
        }
        // Once the for loop finishes, we convert the temp deg to the current deg.
        var curDeg = Math.max(curDeg,tempDeg);
        debugText('Inside the product sign we found the degree is: '+tempDeg);
        debugText('So we set the curDeg to: '+curDeg);
    } else {
        // If it's none of the above, then we should just recurs on any arrays we find.

        debugText('Processing an unknown sign... Specifically: '+tree[position][0]);

        for (var j = 0; j < tree[position].length; ++j) {
            // Walk the array to find any powers of x.
            if (tree[position][j]=='x') {
                // If the entry is just x, then we have deg 1.
                curDeg = Math.max(curDeg,1);
            } else if (Array.isArray(tree[position][j])) {
                // If the term is an array, then we need to recurs to find the degree.
                let tempVal=degreeHunt(tree[position],j,0);
                if (tempVal<0) { return (-1)} else {
                    curDeg = Math.max(curDeg,tempVal);
                }
            }// Any other option is degree 0, so no need for an else.
        }

    }
    debugText('Made it to the end of the degreeHunt function, which means we need to return a curDeg variable, which is: '+curDeg);
    return curDeg
}

// Subfunction just to make sure that the submitted function is in a legitimately factored form.

function JNFisFactored(factorTree) {

    // First we check to see if we have a negative factored out, which messes everything up in the tree.
    if ((factorTree[0]=='-')||(factorTree[0]=='*')||((factorTree[0]=='/')&&(isNum(JNFoperation[1])))
    ) {return true} else {return false}
}

function factorCheck(f,g) {
    // This validator is designed to check that a student is submitting a factored polynomial. It works by:
    //  Checking that the degree of each factor matches between student submitted and instructor submitted answers (NOT order sensitive),
    //  Checking that the submitted answer and the expected answer are the same via real Ximera evaluation,
    //  Checking that the outer most (last to be computed when following order of operations) operation is multiplication.
    //  It ignores degree 0 terms for degree check, and now can ignore factored out negative signs.

    debugText(f.tree);
    debugText(g.tree);

    if (JNFisFactored(g.tree)==false) {
        console.log('Answer rejected, instructor answer not in a factored form. Bad instructor, no donut.');
        return false
    }

    // First we check to make sure it is in *a* factored form:
    if (JNFisFactored(f.tree)==true) {
        console.log('The student answer is at least in *a* factored form.');

    } else {
        console.log('Answer rejected, student answer not in a factored form.');
        return false
    }

    // Let's duplicate the trees to manipulate, so we keep the original correctly.
    var studentAns=f.tree
    var instructorAns=g.tree

    // Also, if there is a factored out negative, let's just kill that, since we aren't doing a funtion comparison on this part:
    while (studentAns[0]=='-'){studentAns = studentAns[1];};
    while (instructorAns[0]=='-'){instructorAns = instructorAns[1];};

    // Now we want to fold up any root-level exponents into duplicate children of the master tree,
    //  This lets us assume the top-level node has 1 child per factor.
    debugText('folding up external exponents of studentTree  so factors do not have exponents');
    for (var i = 0; i < studentAns.length; ++i) {
        if ((studentAns[i][0] == '^')&&(isPosInt(studentAns[i][2]))) {
            studentAns=studentAns.concat(Array(studentAns[i][2]).fill(studentAns[i][1]));
            studentAns.splice(i,1);// This should theoretically remove the original term now that we've duplicated it.
            i=i-1;// since we shortened our array by 1, we should move the iteration value down 1 too.
            debugText('Ok, I folded up a term, so hopefully our student vector still makes sense. It is now: '+studentAns);
        } else if (studentAns[i][0] == '^') {
            //if we have a power, but not a positive integer power, then we have a non-polynomial factor, so we're done.
            console.log('I think I found a non-polynomial term, specifically some root term has a non natural number (or zero) power.');
            return false;
        }
    }
    debugText('After all preprocessing my studentAns vector is:');
    debugText(studentAns);

    // Now re repeat with instructor tree:
    debugText('folding up external exponents of instructorTree so factors do not have exponents')
    for (var i = 0; i < instructorAns.length; ++i) {
        if ((instructorAns[i][0] == '^')&&(isPosInt(instructorAns[i][2]))) {
            instructorAns=instructorAns.concat(Array(instructorAns[i][2]).fill(instructorAns[i][1]));
            instructorAns.splice(i,1);// This should theoretically remove the original term now that we've duplicated it.
            i=i-1;// since we shortened our array by 1, we should move the iteration value down 1 too.
            debugText('Ok, I folded up a term, so hopefully our student vector still makes sense. It is now: '+instructorAns);
        } else if (instructorAns[i][0] == '^') {
            //if we have a power, but not a positive integer power, then we have a non-polynomial factor, so we're done.
            return false;
            console.log('Found a non-polynomial term in the instructor answer... huh... Check the code!');
        }
    }
    debugText('After all preprocessing my instructorAns vector is: '+instructorAns);

    /*
        ::NOW LETS PROCESS THE STUDENT ANSWER::
    */

    var studentDegList=[0]
    for (var i = 0; i < studentAns.length; ++i) {
        if (studentAns[i] == 'x') {
            // If the factor is simply 'x', then it's a degree 1 factor... yay...
            studentDegList.push(1);
            debugText('Found another factors degree, so now studentDegList is: '+studentDegList);
        } else if (Array.isArray(studentAns[i])) {
            // Otherwise, if it is an array, we have something to go hunting in.
            studentDegList.push(degreeHunt(studentAns,i,0));
            debugText('Found another factors degree, so now studentDegList is: '+studentDegList);
        }// Note that the only other possibility is it being a number, which we don't care about.
    }
    studentDegList = studentDegList.filter(x => x!==0);// Remove all zeros from the array to avoid stupid padded constant multipliers.
    studentDegList.sort();// Sort the result so that we can later compare it to the instructor version.
    debugText('The final List of Factor Degrees given by the student is: ' + studentDegList);

    if (studentDegList.some(elem => elem<0)) {
        console.log('I think one of the student factors is NOT a polynomial. So I am rejecting the answer.');
        return false
        }

    /*
        ::NOW LETS PROCESS THE INSTRUCTOR ANSWER::
    */

    var instructorDegList=[0]
    for (var i = 0; i < instructorAns.length; ++i) {
        if (instructorAns[i] == 'x') {
            // If the factor is simply 'x', then it's a degree 1 factor... yay...
            instructorDegList.push(1);
            debugText('Found another factors degree, so now instructorDegList is: '+instructorDegList);
        } else if (Array.isArray(instructorAns[i])) {
            // Otherwise, if it is an array, we have something to go hunting in.
            instructorDegList.push(degreeHunt(instructorAns,i,0));
            debugText('Found another factors degree, so now instructorDegList is: '+instructorDegList);
        }// Note that the only other possibility is it being a number, which we don't care about.
    }
    instructorDegList = instructorDegList.filter(x => x!==0);// Remove all zeros from the array to avoid stupid padded constant multipliers.
    instructorDegList.sort();// Sort the result so that we can later compare it to the instructor version.
    debugText('The final List of Factor Degrees given by the instructor is: ' + instructorDegList);

    if (instructorDegList.some(elem => elem<0)) {
        console.log('I think one of the instructor factors is NOT a polynomial. So I am rejecting the answer.');
        return false
        }

   /*
        ::NOW WE COMPARE::
   */

    if (studentDegList.length!=instructorDegList.length){
        console.log('Ans Rejected: Wrong number of factors.');
        return false;
        }

    for (var i = 0; i < studentDegList.length; ++i) {
        if (studentDegList[i] !== instructorDegList[i]) {
        console.log('Ans Rejected: At least one factor is the wrong degree.');
        return false;
        }
    }

    if (f.equals(g)){
        } else {
        console.log('Ans Rejected: Factors do not expand to original Polynomial.');
        }

    return (f.equals(g));
}


// We want to define a validator that allows us to check against a list of possibilities.
function multiAns(f,g) {
    // We expect that f is a single function provided by the student,
    // We expect that g is a vector of possible acceptable (function) answers provided by the instructor.
    //      The answers should be entered in as a list, using square brackets,
    //      eg [ans1, ans2, ans3]
    //

    // Start out by duplicating the vector of answers to use later.
    instructorAnsbkup = JSON.parse(JSON.stringify(g.tree));

    /* //   Debug Code - commented out now that it is working.
    console.log('Here is the student ans.');
    console.log(f);

    console.log('Here is the instructor ans.');
    console.log(g);
    */

    for (var i = 1; i <= instructorAnsbkup.length; ++i) {
        g.tree = instructorAnsbkup[i];
        console.log('inside the forloop for checking...');
        console.log(g);
        if (f.equals(g)){
            return true
        }
    }
return false
}


// We want to define a validator that allows us to check a matrix.
function equalMatrix(f,g) {
    /* We expect that f is a matrix provided by the student in the format:
            [ [r1c1,r1c2,r1c3],[r2c1,r2c2,r2c3],[r3c1,r3c2,r3c3] ]
       We expect that g is a matrix provided by the instructor in the format:
            [ [r1c1,r1c2,r1c3],[r2c1,r2c2,r2c3],[r3c1,r3c2,r3c3] ]
    */

    debugText('Here is the student ans.');

    debugArray(f);

    debugText('Here is the instructor ans.');

    debugArray(g);

    //  Now we want to make a dummy form of the given variables so we can manipulate them without the original getting recked.

    var fTree = JSON.parse(JSON.stringify(f.tree));
    var gTree = JSON.parse(JSON.stringify(g.tree));

    // Start out by making sure that the format was entered correctly
    //  in particular, that each sub-list is the same length.
    //instructorAnsbkup = JSON.parse(JSON.stringify(g.tree));

    // Santize the instructor's entry.

    for (var i = 1; i < g.tree.length; ++i) {
        if (g.tree[1].length==g.tree[i].length) {
        } else {
            console.log('Looks like the format for the instructors answer is off, [at least] one of the rows has the wrong number of columns!');
            return false
        }
    }

    // Santize the student entry.
    for (var i = 1; i < f.tree.length; ++i) {
        if (f.tree[1].length==f.tree[i].length) {
        } else {
            console.log('Looks like the format for the students answer is off, [at least] one of the rows has the wrong number of columns!');
            return false
        }
    }

    // Now that we have santized the column/rows so that we know we have an actual rectangle, we'll check that the dimensions match.

    if (f.tree.length!==g.tree.length) {
        // If the dimensions aren't the same, then the answer definitely doesn't match the instructors.
        debugText('Looks like the matrix submitted by the student does not have the same dimension as the matrix we expect.');
        return false;
    }

    for (var i = 1; i < f.tree.length; ++i) {
        if (f.tree[i].length==g.tree[i].length) {
        } else {
            debugText('Looks like the matrix submitted by the student does not have the same dimension as the matrix we expect.');
            return false
        }
    }

    // Finally, we check the actual entries.
    // We assume that the matrix is a two dimensional array, i.e. no matrix entries inside our matrix. Tensors can bite me.

    for (var i = 1; i < f.tree.length; ++i) {
        for (var j = 1; j < f.tree[i].length; ++j) {
            debugText('Checking equality of entries in: row ' + i +', column ' + j);

            if ( compSubTree(f,fTree[i][j],gTree[i][j]) ) {
                debugText('They appear equal in student and instructors matricies.');
            } else {
                console.log('Looks like [at least one] of the entries are wrong!');
                debugText('The students answers [raw ans then copied obj ans]')
                debugArray(f.tree[i][j]);
                debugArray(fTree);
                debugText('The students answers [raw ans then copied obj ans]')
                debugArray(g.tree[i][j]);
                debugArray(gTree);
                return false
            }
        }
    }

return true
}

</script></div></body> 
 
</html>
                                                                  


